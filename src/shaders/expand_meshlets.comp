#include "common/bindings.h"

bool cull_bounding_sphere(Instance instance, vec4 bounding_sphere) {
    vec3 world_space_pos = (instance.transform * vec4(bounding_sphere.xyz, 1.0)).xyz;
    float radius = bounding_sphere.w;

    vec3 scale = vec3(
        length(instance.transform[0].xyz),
        length(instance.transform[1].xyz),
        length(instance.transform[2].xyz)
    );
    // 99% of the time scales will be uniform. But in the chance they're not,
    // use the longest dimension.
    float scale_scalar = max(max(scale.x, scale.y), scale.z);

    radius *= scale_scalar;

    vec3 view_space_pos = (uniforms.initial_view * vec4(world_space_pos, 1.0)).xyz;
    // The view space goes from negatives in the front to positives in the back.
    // This is confusing so flipping it here makes sense I think.
    view_space_pos.z = -view_space_pos.z;

    // Is the most positive/forwards point of the object in front of the near plane?
    bool visible = view_space_pos.z + radius > NEAR_PLANE;

    // Do some fancy stuff by getting the frustum planes and comparing the position against them.
    vec3 frustum_x = normalize(transpose(uniforms.perspective)[3].xyz + transpose(uniforms.perspective)[0].xyz);
    vec3 frustum_y = normalize(transpose(uniforms.perspective)[3].xyz + transpose(uniforms.perspective)[1].xyz);

    visible = visible && view_space_pos.z * frustum_x.z + abs(view_space_pos.x) * frustum_x.x < radius;
    visible = visible && view_space_pos.z * frustum_y.z - abs(view_space_pos.y) * frustum_y.y < radius;

    return !visible;
}

layout(local_size_x = 64) in;

void main() {
    uint32_t id = global_id.x;

    if (id >= uniforms.num_instances) {
        return;
    }

    Instance instance = instances[id];
    MeshInfo mesh_info = MeshInfoBuffer(instance.mesh_info_address).mesh_info;

    if (cull_bounding_sphere(instance, mesh_info.bounding_sphere)) {
        return;
    }

    uint32_t meshlets_offset = atomicAdd(misc_storage.num_expanded_meshlets, mesh_info.num_meshlets);

    MeshletIndexBuffer buf = MeshletIndexBuffer(uniforms.expanded_meshlets);

    for (uint32_t i = 0; i < mesh_info.num_meshlets; i++) {
        MeshletIndex index;
        index.instance_index = id;
        index.meshlet_index = i;
        buf.meshlet_index[meshlets_offset + i] = index;
    }
}
