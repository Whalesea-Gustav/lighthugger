#include "common/bindings.glsl"
#include "common/culling.glsl"

layout(local_size_x = 64) in;

void write_draw_calls() {
    uint32_t id = gl_GlobalInvocationID.x;

    if (id >= MiscStorageBuffer(uniforms.misc_storage)
                  .misc_storage.num_expanded_meshlets) {
        return;
    }

    MeshletIndex meshlet_index =
        MeshletIndexBuffer(uniforms.meshlet_indices).meshlet_index[id];

    Instance instance = InstanceBuffer(uniforms.instances)
                            .instances[meshlet_index.instance_index];
    MeshInfo mesh_info = MeshInfoBuffer(instance.mesh_info_address).mesh_info;

    Meshlet meshlet =
        MeshletBuffer(mesh_info.meshlets).meshlets[meshlet_index.meshlet_index];

    if (cull_bounding_sphere(instance, meshlet.bounding_sphere)) {
        return;
    }

    bool alpha_clipped = bool(mesh_info.flags & MESH_INFO_FLAGS_ALPHA_CLIP);

    if (!alpha_clipped && cull_cone_perspective(instance, meshlet)) {
        return;
    }

    uint meshlet_draw_index;

    DrawCallBuffer draw_call_buffer = DrawCallBuffer(uniforms.draw_calls);

    if (alpha_clipped) {
        meshlet_draw_index = ALPHA_CLIP_DRAWS_OFFSET
            + atomicAdd(draw_call_buffer.num_alpha_clip[0], 1);
    } else {
        meshlet_draw_index = atomicAdd(draw_call_buffer.num_opaque[0], 1);
    }
    uint32_t meshlet_indices_buffer_offset =
        meshlet_draw_index + MESHLET_INDICES_BUFFER_SECTION_OFFSET;

    DrawIndirectCommand draw_call;
    draw_call.vertexCount = meshlet.triangle_count * 3;
    draw_call.instanceCount = 1;
    draw_call.firstVertex = 0;
    draw_call.firstInstance = meshlet_indices_buffer_offset;

    draw_call_buffer.draw_calls[meshlet_draw_index] = draw_call;

    MeshletIndexBuffer(uniforms.meshlet_indices)
        .meshlet_index[meshlet_indices_buffer_offset] = meshlet_index;
}

layout(local_size_x = 16, local_size_y = 4) in;

void write_draw_calls_shadows() {
    uint32_t id = gl_GlobalInvocationID.x;
    uint32_t cascade_index = gl_GlobalInvocationID.y;

    if (id >= MiscStorageBuffer(uniforms.misc_storage)
                  .misc_storage.num_expanded_meshlets) {
        return;
    }

    MeshletIndex meshlet_index =
        MeshletIndexBuffer(uniforms.meshlet_indices).meshlet_index[id];

    Instance instance = InstanceBuffer(uniforms.instances)
                            .instances[meshlet_index.instance_index];
    MeshInfo mesh_info = MeshInfoBuffer(instance.mesh_info_address).mesh_info;

    Meshlet meshlet =
        MeshletBuffer(mesh_info.meshlets).meshlets[meshlet_index.meshlet_index];

    bool alpha_clipped = bool(mesh_info.flags & MESH_INFO_FLAGS_ALPHA_CLIP);

    if (cull_bounding_sphere_shadows(
            instance,
            meshlet.bounding_sphere,
            cascade_index
        )) {
        return;
    }

    if (!alpha_clipped && cull_cone_orthographic(instance, meshlet)) {
        return;
    }

    uint meshlet_draw_index;

    DrawCallBuffer draw_call_buffer = DrawCallBuffer(uniforms.draw_calls);

    if (alpha_clipped) {
        meshlet_draw_index = ALPHA_CLIP_DRAWS_OFFSET
            + atomicAdd(draw_call_buffer.num_alpha_clip[cascade_index], 1);
    } else {
        meshlet_draw_index =
            atomicAdd(draw_call_buffer.num_opaque[cascade_index], 1);
    }
    meshlet_draw_index += cascade_index * MESHLET_INDICES_BUFFER_SECTION_OFFSET;
    uint32_t meshlet_indices_buffer_offset =
        meshlet_draw_index + 2 * MESHLET_INDICES_BUFFER_SECTION_OFFSET;

    DrawIndirectCommand draw_call;
    draw_call.vertexCount = meshlet.triangle_count * 3;
    draw_call.instanceCount = 1;
    draw_call.firstVertex = 0;
    draw_call.firstInstance = meshlet_indices_buffer_offset;

    draw_call_buffer.draw_calls[meshlet_draw_index] = draw_call;

    MeshletIndexBuffer(uniforms.meshlet_indices)
        .meshlet_index[meshlet_indices_buffer_offset] = meshlet_index;
}
